#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals, print_function

from optparse import OptionParser
parser = OptionParser(usage='%prog host',
	description='Connect to ssh channel with predefined settings')
parser.add_option('-r', '--root',
	action='store_true', dest='root',
	help='try to log in as root user, regardless of cfg')
parser.add_option('-p', '--persist',
	action='store_true', dest='persist',
	help='try re-connecting until success')
parser.add_option('-l', '--list-hosts',
	action='store_true', dest='list_hosts',
	help='do not connect anywhere, just list known hosts')
parser.add_option('-i', '--ip',
	action='store_true', dest='ip',
	help='connect to IP rather than the hostname')
parser.add_option('-n', '--poll-interval',
	action='store', dest='poll', type='int', default=1, metavar='SEC',
	help='secs to wait between polling to see if process was terminated by SIGINT')
parser.add_option('-w', '--wait',
	action='store', type='int', dest='wait', default=5, metavar='SEC',
	help='secs to wait for process to terminate on signal')
parser.add_option('-a', '--forward-agent',
	action='store_true', dest='fwd_auth',
	help='enable ssh authentication agent forwarding')
parser.add_option('-x', '--disable-Xfwd',
	action='store_false', dest='fwd_x', default=True,
	help='disable X-forwarding')
parser.add_option('-t', '--roam', action='store_true',
	help='Roaming mode (use real hostnames and IPs, not local ones).'
		' Auto-detected by default through wlan0 interface state if host_list.roam exists.')
optz, argz = parser.parse_args()
if not argz and not optz.list_hosts: parser.error('No host specified')


import itertools as it, operator as op, functools as ft
from subprocess import Popen, PIPE
import re, os, sys, types


host_lists = map(os.path.expanduser, ['~/.cFG/host_list', '~/.cFG/host_list.roam'])
host_lists_ext = os.path.expanduser('~/.cFG/host_list.ext')

if optz.roam is None and os.path.exists(host_lists[1]):
	optz.roam = Popen('/sbin/ip link show wlan0'.split(), stdout=PIPE)
	line = optz.roam.stdout.readline()
	if optz.roam.wait():
		print('Failed to detect roaming profile, assuming False', file=sys.stderr)
		optz.roam = False
	else: optz.roam = 'NO-CARRIER' in line or ' DOWN ' in line

hosts = dict(
	# host, (ip,suffix,port); ip isn't needed if connecting to hostname
	(host, (ip if optz.ip else None, suffix, None))
	for ip,fqhn,suffix,host in
		re.findall('^([a-f\d.:]+).*?(\S\.(\w+))?\s+([^\s.]+)\s*$',
			open('/etc/hosts').read(), re.M) )

if os.path.isfile(host_lists_ext):
	for line in open(host_lists_ext):
		try:
			line = line.strip().split('\t')
			if not filter(None, line): continue
			src = os.path.expanduser(line[0])

			if src.endswith('.gpg'):
				if 'GPG_AGENT_INFO' not in os.environ: raise RuntimeError
				proc = Popen(['gpg', '--no-tty', '-qd'], stdin=open(src, 'rb'), stdout=PIPE)
				ext, src = proc.stdout.read(), src[:-4]
				if proc.wait(): raise RuntimeError('GPG subprocess failed')
			else: ext = open(src).read()

			while True:
				if src.endswith('.yaml'):
					import yaml
					ext, src = yaml.load(ext), src[:-5]
				elif src.endswith('.json'):
					import json
					ext, src = json.loads(ext), src[:-5]
				elif src.endswith('.pickle'):
					import pickle
					ext, src = pickle.loads(ext), src[:-6]
				elif isinstance(ext, types.StringTypes):
					ext = map(op.methodcaller('strip'), ext.splitlines())
				else: break

			if len(line) > 2 and line[2]:
				for k in line[2].split('.'): ext = ext[k]
			ext_domain = line[1] if len(line) > 1 and line[1] else None
			if isinstance(ext, types.StringTypes): ext = [ext]
			for ext in ext: hosts[ext] = None, ext_domain, None
		except RuntimeError: pass # these are considered OK here

for line in open(host_lists[int(bool(optz.roam))]):
	line = line.strip()
	if not line or line.startswith('#'): continue
	alias,link = line.split(' ', 1)
	try: host,suffix = alias.rsplit('.', 1)
	except ValueError: host,suffix = alias,None
	try: link,port = link.split('/', 1)
	except ValueError: port = None
	hosts[host] = link,suffix,port

if optz.list_hosts:
	sys.stdout.write(' '.join(hosts.keys()))
	sys.exit()


auth = dict( line.strip().split(' ', 1) for line in
	open(os.path.expanduser('~/.cFG/host_auth')) )

for host,(link,suffix,port) in hosts.iteritems():
	if not link: link = host
	try: hosts[host] = link, auth[suffix], port
	except KeyError: hosts[host] = link, None, port

try:
	host,auth,port = hosts[argz[0]]
	if optz.root: auth = 'root'
except KeyError:
	sys.stderr.write('Unknown host specified\n')
	sys.exit(1)


from time import sleep
import signal
death_seq = 0 # indicates that time to play it nice is over
def key_int(sigid, frame):
	global death_seq
	if death_seq: return proc.send_signal(signal.SIGKILL)
	else:
		optz.persist = False # just in case
		proc.send_signal(signal.SIGINT)
		while death_seq < optz.wait and proc.poll() == None:
			sleep(optz.poll)
			death_seq += optz.poll
		proc.send_signal(signal.SIGTERM)
signal.signal(signal.SIGINT, key_int)


line = ['ssh', '%s@%s'%(auth,host) if auth else host]
if port: line.extend(['-p', str(port)])
if optz.fwd_x: line.append('-Y')
if optz.fwd_auth: line.append('-A')

if not optz.persist:
	sys.stdout.flush()
	sys.stderr.flush()
	os.execvp(line[0], line)
else:
	while True:
		proc = Popen(line)
		try: err = proc.wait()
		except OSError: break # caught signal
		if not err: break
		sleep(optz.poll)

