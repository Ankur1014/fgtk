#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals, print_function

import argparse
parser = argparse.ArgumentParser(
	description='Connect to remote host, whatever that means.')
parser.add_argument('host', nargs='?', help='Host alias to connect to.')
parser.add_argument('-r', '--root', action='store_true',
	help='Try to log in as root user, regardless of cfg.')
parser.add_argument('-s', '--screen', action='store_true',
	help='Start or connect to a screen session on the otherside.')
parser.add_argument('-p', '--persist', action='store_true',
	help='Try re-connecting until success.')
parser.add_argument('-l', '--list-hosts', action='store_true',
	help='Do not connect anywhere, just list known hosts.')
parser.add_argument('-i', '--ip', action='store_true',
	help='Connect to IP rather than the hostname.')
parser.add_argument('-n', '--poll-interval',
	action='store', type=int, default=1, metavar='SEC',
	help='Seconds to wait between polling to see if'
		' process was terminated by SIGINT (default: %(default)s).')
parser.add_argument('-w', '--wait',
	action='store', type=int, default=5, metavar='SEC',
	help='Seconds to wait for process to'
		' terminate on signal (default: %(default)s).')
parser.add_argument('-a', '--forward-auth', action='store_true',
	help='Enable ssh authentication forwarding.')
parser.add_argument('-x', '--disable-Xfwd',
	action='store_false', dest='forward_x', default=True,
	help='Disable X-forwarding.')
parser.add_argument('-t', '--roam', action='store_true',
	help='Roaming mode (use real hostnames and IPs, not local ones).'
		' Should be auto-detected by default if host_list.roam exists.')
parser.add_argument('-v', '--visual', action='store_true',
	help='Enabled randomart key signature display.')
optz = parser.parse_args()

if not optz.host and not optz.list_hosts: parser.error('No host specified')


import itertools as it, operator as op, functools as ft
from subprocess import Popen, PIPE
import re, os, sys, types


host_lists = map(os.path.expanduser, ['~/.cFG/host_list', '~/.cFG/host_list.roam'])
host_lists_ext = os.path.expanduser('~/.cFG/host_list.ext')

if optz.roam is None and os.path.exists(host_lists[1]):
	optz.roam = not os.path.exists('/dev/.net/fg_core') # created by wicd hook

hosts = dict(
	# host, (ip,suffix,port); ip isn't needed if connecting to hostname
	(host, (ip if optz.ip else None, suffix, None))
	for ip,fqhn,suffix,host in
		re.findall('^([a-f\d.:]+).*?(\S\.(\w+))?\s+([^\s.]+)\s*$',
			open('/etc/hosts').read(), re.M) )

if os.path.isfile(host_lists_ext):
	for line in open(host_lists_ext):
		try:
			line = line.strip().split('\t')
			if not filter(None, line): continue
			src = os.path.expanduser(line[0])

			if src.endswith('.gpg'):
				if 'GPG_AGENT_INFO' not in os.environ: raise RuntimeError
				proc = Popen(['gpg', '--no-tty', '-qd'], stdin=open(src, 'rb'), stdout=PIPE)
				ext, src = proc.stdout.read(), src[:-4]
				if proc.wait(): raise RuntimeError('GPG subprocess failed')
			else: ext = open(src).read()

			while True:
				if src.endswith('.yaml'):
					import yaml
					ext, src = yaml.load(ext), src[:-5]
				elif src.endswith('.json'):
					import json
					ext, src = json.loads(ext), src[:-5]
				elif src.endswith('.pickle'):
					import pickle
					ext, src = pickle.loads(ext), src[:-6]
				elif isinstance(ext, types.StringTypes):
					ext = map(op.methodcaller('strip'), ext.splitlines())
				else: break

			if len(line) > 2 and line[2]:
				for k in line[2].split('.'): ext = ext[k]
			ext_domain = line[1] if len(line) > 1 and line[1] else None
			if isinstance(ext, types.StringTypes): ext = [ext]
			for ext in ext: hosts[ext] = None, ext_domain, None
		except RuntimeError: pass # these are considered OK here

for line in open(host_lists[int(bool(optz.roam))]):
	line = line.strip()
	if not line or line.startswith('#'): continue
	alias,link = line.split(' ', 1)
	try: host,suffix = alias.rsplit('.', 1)
	except ValueError: host,suffix = alias,None
	try: link,port = link.split('/', 1)
	except ValueError: port = None
	hosts[host] = link,suffix,port

if optz.list_hosts:
	sys.stdout.write(' '.join(hosts.keys()))
	sys.exit()


auth = dict( line.strip().split(' ', 1) for line in
	open(os.path.expanduser('~/.cFG/host_auth')) )

for host,(link,suffix,port) in hosts.iteritems():
	if not link: link = host
	try: hosts[host] = link, auth[suffix], port
	except KeyError: hosts[host] = link, None, port

try:
	host,auth,port = hosts[optz.host]
	if optz.root: auth = 'root'
except KeyError:
	sys.stderr.write('Unknown host specified\n')
	sys.exit(1)


from time import sleep
import signal
death_seq = 0 # indicates that time to play it nice is over
def key_int(sigid, frame):
	global death_seq
	if death_seq: return proc.send_signal(signal.SIGKILL)
	else:
		optz.persist = False # just in case
		proc.send_signal(signal.SIGINT)
		while death_seq < optz.wait and proc.poll() == None:
			sleep(optz.poll_interval)
			death_seq += optz.poll_interval
		proc.send_signal(signal.SIGTERM)
signal.signal(signal.SIGINT, key_int)


line = ['ssh', '%s@%s'%(auth,host) if auth else host]
if port: line.extend(['-p', str(port)])
if optz.forward_x: line.append('-Y')
if optz.forward_auth: line.append('-A')
if optz.visual: line.append('-oVisualHostKey=yes')
if optz.screen: line.extend(['-t', 'screen', '-DR'])

if not optz.persist:
	sys.stdout.flush()
	sys.stderr.flush()
	os.execvp(line[0], line)
else:
	while True:
		proc = Popen(line)
		try: err = proc.wait()
		except OSError: break # caught signal
		if not err: break
		sleep(optz.poll_interval)
