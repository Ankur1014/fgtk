#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals, print_function

import itertools as it, operator as op, functools as ft
from collections import OrderedDict
from glob import glob
from os.path import join, expanduser, isdir
import os, sys, pyaml, json


def find_profile():
	profile = None
	for path in glob(expanduser('~/.mozilla/firefox/*.default')):
		if isdir(join(path, 'tabgroupsmanagerdata')):
			if profile: raise KeyError('There is more than one firefox profile')
			profile = path
	if not profile: raise KeyError('Unable to find firefox profile dir')
	return profile


def main():
	import argparse
	parser = argparse.ArgumentParser(
		description='Tool to work with stored data of Firefox TabGroupManager2 extension.'
			' Default action: show all groups/tabs, stored in the last dump.')
	parser.add_argument('-p', '--ff-profile',
		help='Path to firefox profile (default: autodetect, if there is only one).')
	parser.add_argument('--debug', action='store_true', help='Verbose output.')
	optz = parser.parse_args()

	import logging
	logging.basicConfig(level='DEBUG' if optz.debug else 'WARNING')
	log = logging.getLogger()

	if not optz.ff_profile:
		try: optz.ff_profile = find_profile()
		except KeyError as err:
			parser.error('Failed to auto-detect ff profile: {}'.format(err.message))

	tgm_dir = join(optz.ff_profile, 'tabgroupsmanagerdata', 'save_data')

	## Default (well, only) action
	latest_tgm2, latest_tgm2_mtime = None, 0
	for tgm2 in glob(join(tgm_dir, '*.tgm2')):
		tgm2_mtime = os.stat(tgm2).st_mtime
		if tgm2_mtime > latest_tgm2_mtime:
			latest_tgm2, latest_tgm2_mtime = tgm2, tgm2_mtime

	tg = dict()
	with open(latest_tgm2) as src:
		tgm_tag = src.readline().strip()
		for tg_type in 'inactive', 'closed', 'active':
			for i in xrange(int(src.readline().strip().split(':', 1)[-1])):
				tg.setdefault(tg_type, list()).append(json.loads(src.readline()))

	groups = OrderedDict()
	for session in tg['active']:
		for tab in session['windows'][0]['tabs']:
			group_name = tab['extData']['TabGroupsManagerGroupName']
			if not tab['entries']: continue
			tab = tab['entries'][0]
			if group_name not in groups:
				groups[group_name] = OrderedDict()

			# Pick unique tab name
			tab_name = tab_name_base = tab.get('title', tab['url'])
			tab_idx = iter(xrange(2**30))
			while tab_name in groups: tab_name = '{} #{}'.format(tab_name_base, next(tab_idx))

			groups[group_name][tab_name] = tab['url']

	pyaml.dump(groups, sys.stdout, vspacing=[1, 0])


if __name__ == '__main__': main()
