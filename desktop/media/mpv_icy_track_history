#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function

from subprocess import Popen, PIPE
import os, sys, logging, re, time, signal


track_max_len = 16384

class MpvCtl(object):

	player_cmd_base = ['mpv', '--input-terminal', '--term-status-msg=']
	player = track_last = None
	muted = muted_auto = muted_change = False

	def __init__(self, dst_file=None, mute_re=None, mute_delay=None, ts_format=None):
		self.log = logging.getLogger('mpvctl')

		self.ts_format = ts_format
		self.mute_re, self.mute_delay = mute_re, mute_delay
		if dst_file:
			self.dst = dst = open(dst_file, 'a+b')
			dst.seek(max(0, os.fstat(dst.fileno()).st_size - (track_max_len + 2)))
			last_line = dst.read()
			if '\n' in last_line:
				self.track_last = last_line.rstrip('\r\n').rsplit('\n', 1)[-1].strip()
		else:
			self.dst = sys.stdout

		self.install_mute_sig_handler()
		if mute_re: self.install_mute_sig_handler(signal.SIGALRM)

	def install_mute_sig_handler(self, sig=signal.SIGQUIT):
		signal.signal(sig, self.send_mute)

	def terminate(self):
		if not (self.player and self.player.poll() is None): return
		self.log.debug('Terminating running player instance')
		self.player.terminate()

	def send_mute(self, sig=None, frm=None):
		if not self.player: return
		if self.muted_change: return
		self.muted_change = True # racy lock
		self.muted = not self.muted
		auto = sig is True or sig == signal.SIGALRM
		if auto:
			if not self.muted_auto: return
		elif self.muted_auto: self.muted_auto = False # manual action
		if not self.muted: self.muted_auto = False
		self.log.debug( 'Toggling "mute" on a running player'
			' instance (sig: %s, auto: %s) to: %s', sig, auto, self.muted )
		self.player.stdin.write('m')
		self.player.stdin.flush()
		self.muted_change = False
		return self.muted

	def _send_mute_auto(self):
		if not self.mute_delay or self.mute_delay < 0: self.send_mute(True)
		else: signal.alarm(self.mute_delay)

	def send_mute_auto(self, enable):
		if enable:
			if self.muted: return
			self.muted_auto = True
			self._send_mute_auto()
		else:
			if not self.muted_auto: return
			self._send_mute_auto()

	def track_match(self, line):
		line = line.strip()
		if not line.startswith('icy-title:'): return
		track = line[10:].strip()
		if self.track_last and self.track_last.endswith(track): return
		self.track_last = track
		return track

	def track_changed(self, track):
		if self.mute_re:
			if self.mute_re.search(track): self.send_mute_auto(True)
			elif self.muted_auto: self.send_mute_auto(False)
		self.track_dump(track)

	def track_dump(self, track):
		prefix = time.strftime(self.ts_format) if self.ts_format else ''
		self.dst.write('{}{}\n'.format(prefix, track))
		self.dst.flush()

	def track_dump_loop(self, opts):
		player_cmd = self.player_cmd_base + list(opts.mpv_args)
		ts = time.time()
		while True:
			if self.player:
				player_poll = self.player.poll()
				if player_poll is not None:
					self.player = None
					player_poll = self.player.wait()
					if player_poll != 0:
						self.log.error('mpv failed (exit code: %s), exiting', player_poll)
						return player_poll

			if not self.player:
				self.player = Popen( player_cmd,
					stdin=PIPE, stdout=PIPE, preexec_fn=os.setsid )

				for line in iter(self.player.stdout.readline, ''):
					if opts.passthrough: self.log.debug(line.rstrip())
					track = self.track_match(line)
					if not track: continue
					self.track_changed(track)


def main(args=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Record whatever is playing in mpv (as supplied by icy-* tags) to some file.'
			' Sending SIGQUIT (Ctrl+\ from terminal) toggles mute for the playback'
				' (actually writes "m" char to mpv stdin, which is bound to "mute" by default).')
	parser.add_argument('mpv_args', nargs='+',
		help='Options/arguments (including playback source) to pass to mpv.'
			' Some terminal-io options will be prepended to these as well.'
			' Use "--" to make sure its options wont get processed by this wrapper script.')

	parser.add_argument('-m', '--mute-regexp', metavar='regexp',
		help='Toggle mute than track name matches'
			' that regexp, unmuting than name changes again.')
	parser.add_argument('--mute-delay', type=float, metavar='seconds', default=1,
		help='When auto-toggling mute, delay by this many seconds'
			' (useful for long track crossfades, default: %(default)s).')

	parser.add_argument('-d', '--dst-file',
		help='Path to a file to record all the stuff to. If omitted, stdout will be used.')
	parser.add_argument('-t', '--timestamp', action='store_true',
		help='Prepend timestamps to each track entry in the output.')
	parser.add_argument('--timestamp-format',
		metavar='py_ts_format', default='[%Y-%m-%d %H:%M] ',
		help='Format for timestamp-prefix to be prepended to each line (default: %(default)s).'
			' Should be compatible with pythons strftime() functions.')

	parser.add_argument('--passthrough',
		action='store_true', help='Pass all mpv stdout lines to debug logging.')
	parser.add_argument('--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	logging.basicConfig(level=logging.DEBUG if opts.debug else logging.WARNING)

	mpvctl = MpvCtl( dst_file=opts.dst_file,
		mute_re=re.compile(opts.mute_regexp), mute_delay=opts.mute_delay,
		ts_format=opts.timestamp and opts.timestamp_format )
	try: return mpvctl.track_dump_loop(opts)
	finally: mpvctl.terminate()

if __name__ == '__main__': sys.exit(main())
