#!/bin/bash


### Process CLI

idx= output= sink=wiretap

while [[ -n "$1" ]]; do
	case "$1" in
		-h|--help) echo "Usage: $0 $(awk '
				func print_arg() {
					if (!ac) ac=""; else ac=sprintf(" ...(%s)", ac)
					if (ap) printf("[ %s%s ] ", ap, ac) }
				/^\s+case\>/ {parse=1; next}
				/^\s+esac\>/ {print_arg(); exit}
				!parse {next}
				match($0, /^\s*([\-|a-z]+)\)/, a) { print_arg(); ap=a[1]; ac=0 }
				!match(ap,/\<-h|--help\>/)\
					{for (i=1;i<NF;i++) if (match($i, /\<shift\>/)) ac++}'\
			$0)"
			exit 0 ;;
		-d|--debug) set -x ;;
		-s|--sink-name) shift; sink=$1 ;;
		-o|--output) shift; output=$1 ;;
		-i|--index) shift; idx=$1 ;;
		*) echo "Unknown arg/option: $1" && exit 1 ;;
	esac
	shift
done


### Try to auto-guess index

if [[ -z "$idx" ]]; then
	idx=$(
		pacmd list-sink-inputs |
		awk '
			match($0,/^\s*index: ([0-9]+)\s*$/,a) {idx=a[1]}
			idx && $1=="application.process.binary" &&\
				match($0,/\<plugin-container\>/) {print idx}' )
	[[ -z "$idx" ]] && {
		echo >&2\
			'Failed to get stream index from "pacmd list-sink-inputs",'\
				' specify it on commandline or something'
		exit 1
	}
fi


### Find existing sink with that name, or create one

sink_idx=$(
	pacmd list-sinks |
	awk '
		match($0,/^\s*index: ([0-9]+)\s*$/,a)\
			{if (parse) print idx; parse=1}
		parse && $1=="name:" &&\
			!match($2,/<\<'"$sink"'\>>/) {parse=0}
		parse && $1=="module:" {idx=$2}
		END {if (parse) print idx}' )

[[ -z "$sink_idx" ]] && sink_idx=$(
	pactl load-module module-null-sink sink_name="$sink" )
[[ -z "$sink_idx" ]] && { echo >&2 'Failed to get/open sink'; exit 1; }

pactl move-sink-input "$idx" "$sink"

if [[ -z "$output" ]]
then parec -d "$sink".monitor
else parec -d "$sink".monitor | oggenc -o "$output" --raw -
fi

trap "pactl unload-module $sink_idx" EXIT
