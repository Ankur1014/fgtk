#!/usr/bin/env python

import itertools as it, operator as op, functools as ft
from plumbum import local
from time import time
from os.path import basename, dirname, join, exists
import os, sys, re, random


def main(argv=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Randomly pick and copy tracks from source to destination.')
	parser.add_argument('src', nargs='+', help='Source path(s).')
	parser.add_argument('dst', help='Destination path.')
	parser.add_argument('-s', '--min-df',
		type=float, metavar='MiB', help='Threshold of df on dst path to stop on.')
	parser.add_argument('-c', '--clean-df',
		type=float, metavar='MiB', help='Before copying stuff, clean up files from'
			' destination path (also see --clean-path) up to specified free-space'
			' threshold (or until theres nothing left). Files to remove are picked at random.')
	parser.add_argument('-a', '--clean-as-necessary',
		action='store_true', help='Clean up files from destination path'
			' (also see --clean-path) as necessary to copy *all* the source files.'
			' Files to remove are picked at random. Mutually exclusive with --min-df.')
	parser.add_argument('-r', '--clean-path',
		help='Clean stuff from the specified path instead of destination.')
	parser.add_argument('--dry-run', action='store_true', help='Dont do the actual cp/rm part.')
	parser.add_argument('--debug', action='store_true', help='Verbose operation mode.')
	optz = parser.parse_args(argv if argv is not None else sys.argv[1:])

	import logging
	logging.basicConfig(level=logging.DEBUG if optz.debug else logging.INFO)
	log = logging.getLogger()

	if optz.clean_as_necessary and optz.min_df:
		parser.error('Options --min-df and --clean-as-necessary do not make sense together')

	MiB = 2**20
	if not exists(optz.dst):
		local['mkdir']('-p', optz.dst)
		log.debug('Created: {}'.format(optz.dst))
	if optz.min_df: optz.min_df = optz.min_df * MiB

	optz.clean = optz.clean_df or optz.clean_as_necessary
	if optz.clean:
		if optz.clean_df: optz.clean_df = optz.clean_df * MiB
		if not optz.clean_path: optz.clean_path = optz.dst

	def force_bytes(path):
		if isinstance(path, unicode): return path.encode('utf-8')
		return path

	def free(path=optz.dst):
		df = os.statvfs(path)
		return float(df.f_bavail * df.f_bsize)

	def pop_path(path_list):
		idx = random.randint(0, len(path_list) - 1)
		path = path_list.pop(idx)
		return path

	def do_cleanup(df_goal=optz.clean_df):
		if optz.dry_run: return
		while cleanup:
			df = free(optz.clean_path)
			if df >= df_goal: break
			path = force_bytes(pop_path(cleanup))
			log.debug(
				'Removing file (df: {:.1f} / {:.1f} MiB): {!r}'\
				.format(df / MiB, df_goal / MiB, path) )
			try: os.unlink(path)
			except OSError as err:
				log.warn('Failed to remove file ({}): {}'.format(path, err))

	# Build a list of files we're allowed to remove, if any cleanup is requested
	if optz.clean:
		cleanup = list()
		if not exists(optz.clean_path):
			log.info('Cleanup path does not exists: {}'.format(optz.clean_path))
		else:
			if optz.clean_df:
				log.debug(
					'Starting cleanup (up to: {:.1f} MiB) of the path: {!r}'\
					.format(optz.clean_df / MiB, optz.clean_path) )
			code, cleanup, err = local['find'].run([optz.clean_path, '-type', 'f'])
			cleanup = cleanup.splitlines()
			if optz.clean_df: do_cleanup() # do pre-cleanup, if enabled

	# Build file list
	log.debug('Building list of files in source paths')
	code, src_files, err = local['find'].run(list(optz.src) + ['-type', 'f'])
	if code or err:
		sys.stderr.write(err)
		raise RuntimeError('find (paths: {!r}) exited with non-zero status'.format(optz.src))
	src_files = src_files.splitlines()
	log.debug(' - found {} files'.format(len(src_files)))

	# Stats
	df0, ts0 = free(), time()
	stats = lambda: 'Done: {:.1f} MiB, rate: {:.2f} MiB/s'.format((df0 - df) / MiB, rate / MiB)

	# Copy files
	while src_files:
		df = free()
		rate = (df0 - df) / (time() - ts0)

		if optz.min_df:
			if df < optz.min_df: break
			to_fill = df - optz.min_df
			time_left = int(to_fill / rate) if rate != 0 else 0
			time_left = '{}m {}s'.format(time_left / 60, time_left % 60)
			log.debug(
				' - space left to fill: {:.1f} MiB, rate: {:.2f} MiB/s, left: {}'\
				.format(to_fill / MiB, rate / MiB, time_left) )

		path = force_bytes(pop_path(src_files))
		log.debug('Copying: {!r}'.format(path))

		path_dst = join(optz.dst, basename(path))
		try:
			if optz.clean_as_necessary: # free space for a file, if requested
				df_path = os.stat(path).st_size
				if df < df_path: do_cleanup(df_path)
			if not optz.dry_run: local['rsync']('--inplace', '--size-only', path, path_dst)
		except KeyboardInterrupt:
			try: os.unlink(path_dst)
			except OSError: pass
			log.info('Aborted. {}'.format(stats()))
			sys.exit()

	# Success
	rate = (df0 - free()) / (time() - ts0)
	log.info(stats())


if __name__ == '__main__': main()
