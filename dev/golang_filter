#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function

import itertools as it, operator as op, functools as ft
from contextlib import contextmanager
from collections import defaultdict
from tempfile import NamedTemporaryFile
from os.path import dirname, basename, join, exists
from subprocess import Popen, PIPE
import os, sys, re, io, stat

import pyparsing as pp


class Actions(object):


	@classmethod
	def itercode(cls, src):
		for line in iter(src, ''):
			yield line, line.strip(), len(line) - len(line.lstrip('\t'))

	@classmethod
	def check_noncode(cls, ls, src, blocks=True):
		return not ls or ls.startswith('//')\
			or (blocks and cls.skip_block(ls, src))

	@classmethod
	def skip_block(cls, line, src):
		res = False
		if line.count('`')%2: # string blocks
			for line in iter(src, ''):
				if line.count('`')%2: break
			res = True
		if re.search(r'^\s*/\*\s', line): # comment blocks
			for line in iter(src, ''):
				if re.search(r'^(.*\s+)?\*/\s*$', line): break
			res = True
		return res


	@classmethod
	def curl(cls, src):
		## Find all places where indentation changes or case-blocks
		cancer, brace_stack = defaultdict(lambda: defaultdict(str)), list()
		pos_prev_tabs, pos_prev = None, src.tell()
		case_block = False
		for line, ls, pos_tabs in cls.itercode(src.readline):
			if cls.check_noncode(ls, src.readline): continue # comments / empty lines
			if cls.skip_block(line, src.readline): continue # block comments/strings
			if pos_prev_tabs is None: # first meaningful line
				pos_prev_tabs, pos_prev = pos_tabs, src.tell() - len(line)
				continue

			if pos_tabs > pos_prev_tabs: # block start (indent++)
				assert pos_tabs - pos_prev_tabs == 1
				if case_block: case_block = False # "case:" insides
				else:
					pos = src.tell()
					src.seek(pos_prev)
					ls_prev = src.readline().strip()
					src.seek(pos)
					bo, bc = '()' if re.search(r'^import\b', ls_prev) else '{}'
					brace_stack.append((pos_prev, bo, bc))
					cancer[pos_prev]['open'] += bo

			elif pos_tabs < pos_prev_tabs: # block end (indent--)
				for n in xrange(pos_prev_tabs - pos_tabs):
					pos_open, bo, bc = brace_stack[-1]
					if bo is None and bc is None: # "case:" end
						if not re.search(r'^(case\b.*|default\s*):$', ls):
							brace_stack.pop()
							cancer[pos_prev]['close'] += '}'
						else: case_block = True # next "case:" follows
					else: # block end proper
						brace_stack.pop()
						if re.search(r'^else\b', ls): # special case - "} else {"
							cancer[src.tell() - len(line)]['soft_close'] += bc
						else: cancer[pos_prev]['close'] += bc

			else:
				if re.search(r'^(case\b.*|default\s*):$', ls): # detect same-indent "case:" blocks
					if not case_block:
						pos = src.tell()
						src.seek(pos_prev)
						ls_prev = src.readline().strip()
						src.seek(pos)
						assert re.search(r'^(switch|select)\b', ls_prev), ls_prev
						brace_stack.append((pos_prev, None, None))
						case_block = True
						cancer[pos_prev]['open'] += '{'
				else: assert not case_block

			pos_prev_tabs, pos_prev = pos_tabs, src.tell() - len(line)

		## Close any remaining blocks
		if brace_stack:
			for pos_open, bo, bc in brace_stack:
				cancer[pos_prev]['close'] += bc

		## Bloatify source
		src.seek(0)
		result, pos_prev = list(), src.tell()
		for pos_line, braces in sorted(cancer.viewitems()):
			# Read to the next brace-line
			assert pos_line >= pos_prev
			result.append(src.read(pos_line - pos_prev))
			assert pos_line == src.tell(), [result[-1][-100:], pos_line, src.tell(), pos_prev]
			# Append cancer
			line = src.readline()
			bo, bc = it.imap(braces.get, ['open', 'close'])
			pos_tabs, line = len(line) - len(line.lstrip('\t')), line.strip()
			if braces.get('soft_close'): # "} else {"
				line = braces.get('soft_close') + ' ' + line
			result.append(
				'\t'*pos_tabs + line
				# + (((' ' if not re.search(r'\[\S*\]\w+\s*$', line) else '') + bo) if bo else '')
				+ ((' ' + bo) if bo else '')
				+ (''.join( ('\n' + '\t'*(pos_tabs-n) + b)
					for n,b in enumerate(bc, 1) ) if bc else '') + '\n' )
			pos_prev = src.tell()
		result.append(src.read())

		return ''.join(result)


	@classmethod
	def uncurl(cls, src):
		## Find position of every to-be-removed brace
		blanks, pos_prev = defaultdict(bytes), src.tell()
		for line, pos_line, pos_tabs in cls.itercode(src.readline):
			if cls.check_noncode(pos_line, src.readline):
				pos_prev = src.tell()
				continue
			for bo,bc in it.izip('{(', '})'):
				if not pos_line.endswith(bo): continue # opening block-brace at eol
				pos, pos_open_line = src.tell(), pos_prev
				# Find tab or a closing brace
				pos_prev = src.tell()
				for line, ls, line_tabs in cls.itercode(src.readline):
					if not cls.check_noncode(ls, src.readline):
						line_tabs = len(line) - len(line.lstrip('\t'))
						if line_tabs == pos_tabs and re.search(r'^\{}(\s+else\b)?'.format(bc), ls):
							# Found closing brace (and maybe opening one on the same line)
							blanks[pos_open_line] += bo + bc
							blanks[pos_prev] += bo + bc
							break
						elif line_tabs <= pos_tabs: # case in either switch or select, otherwise error
							assert re.search(r'^(switch|select)\b', pos_line), pos_line
							assert re.search(r'^(case|default)\b', ls), ls
					pos_prev = src.tell()
				else: raise ValueError('No closing brace found for line: {!r}'.format(line))
				src.seek(pos) # return to next line within the block
			pos_prev = src.tell()

		## Build a clean version of source
		src.seek(0)
		result, pos_prev = list(), src.tell()
		for pos_line, braces in sorted(blanks.viewitems()):
			# Read to the next brace-line
			assert pos_line >= pos_prev
			result.append(src.read(pos_line - pos_prev))
			assert pos_line == src.tell(), [result[-1][-100:], pos_line, src.tell(), pos_prev]
			# Drop braces and spaces near these
			line = src.readline()
			assert any((c in line) for c in braces)
			pos_tabs, line = len(line) - len(line.lstrip('\t')), line.strip().strip(braces).strip()
			if line: result.append('\t'*pos_tabs + line + '\n')
			pos_prev = src.tell()
		result.append(src.read())

		return ''.join(result)


	@classmethod
	def replace(cls, path, contents, update_mtime=False):
		assert exists(path)
		with NamedTemporaryFile( dir=dirname(path),
				prefix=basename(path)+'.', delete=False ) as tmp:
			pstat = os.stat(path)
			try:
				tmp.write(contents)
				tmp.flush()
				os.fchmod(tmp.fileno(), stat.S_IMODE(pstat.st_mode))
				if not update_mtime:
					os.utime(tmp.name, (pstat.st_mtime, pstat.st_mtime))
				os.fsync(tmp.fileno())
				os.rename(tmp.name, path)
			finally:
				try: os.unlink(tmp.name)
				except OSError: pass



class NoChange(Exception): pass
class IrreversibleOperation(Exception): pass


def main(argv=None, optz=None):
	if not optz:
		import argparse
		parser = argparse.ArgumentParser(
			description='Pythonify Go sources by removing all brace-cancer.'
				' Operation is perfectly reversible and is checked with "diff -u"'
					' (reverse vs original) on "uncurl" command (unless --force is specified).')
		cmds = parser.add_subparsers(
			title='Supported operations (have their own suboptions as well)')

		@contextmanager
		def subcommand(name, call=None, **kwz):
			cmd = cmds.add_parser(name, **kwz)
			cmd.set_defaults(call=call or name)
			yield cmd

		with subcommand('uncurl', help='Remove curly braces.') as cmd:
			cmd.add_argument('path', help='File to process.')
			cmd.add_argument('-f', '--force', action='store_true',
				help='Dont run "diff" to check whether changes are perfectly reversible.')
		with subcommand('curl', help='Add curly braces.') as cmd:
			cmd.add_argument('path', help='File to process.')

		with subcommand('git-smudge', call='git-uncurl',
				help='Same as "uncurl", but git-filter friendly'
					' - works with stdin/stdout, different error handling.') as cmd:
			cmd.add_argument('path', help='Filename. Ignored - git'
				' supplies contents on stdin and expects processing results on stdout.')
			cmd.add_argument('-f', '--force', action='store_true',
				help='Dont run "diff" to check whether changes are perfectly reversible.')
		with subcommand('git-clean', call='git-curl',
				help='Same as "curl", but git-filter friendly'
					' - works with stdin/stdout, different error handling.') as cmd:
			cmd.add_argument('path', help='Filename. Ignored - git'
				' supplies contents on stdin and expects processing results on stdout.')

		parser.add_argument('-n', '--dry-run', action='store_true',
			help='Dont replace the files, just output mangled source. Ignored with git-* commands.')
		parser.add_argument('-t', '--update-mtime', action='store_true',
			help='Dont restore original timestamps of changed files'
				' (done to work better with make, editors). Ignored with git-* commands.')
		optz = parser.parse_args(sys.argv[1:] if argv is None else argv)

	if optz.call.startswith('git-'):
		git_mode, optz.call = True, optz.call.split('-', 1)[-1]
	else: git_mode = False

	try:
		src, dst = (io.BytesIO(sys.stdin.read()), sys.stdout)\
			if git_mode else (open(optz.path), None if not optz.dry_run else sys.stdout)

		result = getattr(Actions, optz.call)(src)

		if optz.call == 'uncurl' and not optz.force:
			# Make sure that it's possible to restore original source
			with NamedTemporaryFile() as tmp1,\
					NamedTemporaryFile() as tmp2:
				src.seek(0)
				tmp1.write(src.read())
				tmp1.flush()
				if dst is not sys.stdout: # check if contents were changed
					tmp2.write(result)
					tmp2.flush()
					proc = Popen(['diff', '-u', tmp1.name, tmp2.name], stdout=PIPE)
					diff = proc.stdout.read()
					if not diff and not proc.wait(): raise NoChange()
					tmp2.seek(0)
				src_rev = io.BytesIO(result)
				tmp2.write(Actions.curl(src_rev))
				tmp2.flush()
				proc = Popen(['diff', '-u', tmp1.name, tmp2.name], stdout=PIPE)
				diff = proc.stdout.read()
				if diff or proc.wait():
					raise IrreversibleOperation(diff)

		if dst is None:
			Actions.replace(optz.path, result, update_mtime=optz.update_mtime)
		else: dst.write(result)

	except Exception as err:
		if not git_mode: raise
		# Less verbose errors for git, as there can potentially be a lot of these
		if isinstance(err, IrreversibleOperation): err = 'Irreversible operation'
		print(' -- Failed processing path: {} - {}'.format(optz.path, err), file=sys.stderr)
		sys.exit(1)


if __name__ == '__main__':
	try: main()
	except NoChange: sys.exit(0)
	except IrreversibleOperation as err:
		print('Failed to do reverse-transformation flawlessly', file=sys.stderr, end='\n\n')
		print(err.args[0], file=sys.stderr, end='')
		sys.exit(1)
