#!/usr/bin/python -B
# -*- coding: utf-8 -*-
from __future__ import unicode_literals, print_function

import itertools as it, operator as op, functools as ft
import os, sys, codecs


def parse_cli( argv=sys.argv,
		_flags='a', _actions={'clean', 'smudge', 'mangle'} ):
	# Yeah, argparse rocks ;)
	if not argv[1:]:
		print(( 'Usage: {} [ space_num [ flags ] ]'
			' ( clean | smudge | mangle ) path' ).format(argv[0]), file=sys.stderr)
		print('Flags:\n'
			'  a - remove or replace alignment spaces (non-divisable by indent).',
			file=sys.stderr )
		sys.exit(1)
	convert, flags = 4, ''
	argv = argv[1:]
	try: action, path = argv
	except ValueError:
		try: convert, action, path = argv
		except ValueError: convert, flags, action, path = argv
	enc, convert = 'utf-8', ['\t', int(convert)]
	if action not in _actions:
		raise ValueError( 'Unknown action'
			' ({}), allowed: {}'.format(action, ', '.join(_actions)) )
	if set(flags).difference(_flags):
		raise ValueError( 'Unknown flags specified'
			' ({}), allowed: [{}]'.format(flags, '] ['.join(_flags)) )
	return action, path, convert, flags, enc

action, path, convert, flags, enc = parse_cli()


codecs = list(getattr(codecs, k)(enc) for k in ['getreader', 'getwriter'])
for k, codec in it.izip(['stdin', 'stdout'], codecs):
	setattr(sys, k, codec(getattr(sys, k)))


def filter_base(src, seqs, dst=sys.stdout):
	src_seq, dst_seq = (( (' '*seq)
		if isinstance(seq, int) else seq ) for seq in seqs)
	src_seq_len = len(src_seq)
	for line in src:
		indent = ''
		while line.startswith(src_seq):
			indent, line = dst_seq+indent, line[src_seq_len:]
		# Handle half-indents and weird space-alignment
		if 'a' in flags:
			if src_seq_len > 1 and isinstance(seqs[0], int) and line.startswith(' '):
				line, line_len = line.lstrip(' '), len(line)
				if line_len - len(line) >= float(seqs[0]) / 2: indent += dst_seq
		# Done
		dst.write(indent + line)

# convert = [from: str or int, to: str or int], where int is a number of spaces
filter_clean = ft.partial(filter_base, seqs=convert)
filter_smudge = ft.partial(filter_base, seqs=list(reversed(convert)))


# git-friendly actions
if action == 'clean': filter_clean(sys.stdin)
elif action == 'smudge': filter_smudge(sys.stdin)

# manual
elif action == 'mangle':
	from tempfile import NamedTemporaryFile
	import io, stat, hashlib

	with codecs[1](NamedTemporaryFile(
			delete=False,
			dir=os.path.dirname(path),
			prefix=os.path.basename(path + '.') )) as tmp:
		try:
			filter_smudge(io.open(path, encoding=enc), dst=tmp)
			tmp.flush()
			if not op.eq(*(hashlib.sha1(
					io.open(path, 'rb').read() ).digest() for path in [path, tmp.name])):
				os.chmod(tmp.name, stat.S_IMODE(os.stat(path).st_mode))
				os.rename(tmp.name, path)
		finally:
			if os.path.exists(tmp.name):
				try: os.unlink(tmp.name)
				except Exception as err:
					print('Failed to remove tmp file ({}): {}'.format(tmp.name, err), file=sys.stderr)

else:
	raise ValueError('Unsupported action: {}'.format(action))
