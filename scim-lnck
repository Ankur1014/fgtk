#!/usr/bin/env python
from __future__ import print_function


from optparse import OptionParser
parser = OptionParser(usage='%prog [options]')
parser.add_option('-f', '--fix',
	action='store_true', dest='fix',
	help='Fix detected errors.')
parser.add_option('-l', '--limit',
	action='store', dest='limit',
	type='int', metavar='NUM',
	help='Process only given number of correctable errors from top of the file.')
parser.add_option('--links-list',
	action='store', dest='list',
	type='str', metavar='NAME', default='.scim_links',
	help='Either basename (which will be searched upwards from cwd) or full path of links-list file. Default: %default')
parser.add_option('--links-exclude',
	action='store', dest='exclude',
	type='str', metavar='NAME', default='.scim_links_exclude',
	help='Either basename (which will be searched upwards from cwd) or full path of links-exclude file. Should be in the same path as links-list. Default: %default')
parser.add_option('--debug',
	action='store_true', dest='debug',
	help='Give extra info on whats going on.')
optz,argz = parser.parse_args()
if argz: parser.error('This command takes no arguments')


import itertools as it, operator as op, functools as ft
from fgc import sh, exe
import os, sys, logging

logging.basicConfig(level=(logging.INFO if not optz.debug else logging.DEBUG))
log = logging.getLogger(sys.argv[0])


### Find scim-root
if optz.list.startswith('/'):
	scim_path, optz.list = scim_path.rsplit(os.sep, 1)
else:
	scim_path = os.getcwd()
	while os.sep in scim_path and not os.path.exists(sh.join(scim_path, optz.list)):
		scim_path = scim_path.rsplit(os.sep, 1)[0]
	if os.sep not in scim_path:
		parser.error('Unable to determine scim-path location')

src, optz.exclude = optz.exclude, os.path.basename(optz.exclude)
if src.startswith('/') and os.path.exists(src) and not os.path.exists(sh.join(scim_path, optz.exclude)):
	parser.error('links-list and links-exclude files should be in the same path')

scim_list = sh.join(scim_path, optz.list)
scim_list = it.ifilter(None, it.imap(str.strip, open(scim_list)))\
	if os.path.exists(scim_list) else list()
scim_exclude = sh.join(scim_path, optz.exclude)
scim_exclude = filter(None, it.imap(str.strip, open(scim_exclude)))\
	if os.path.exists(scim_exclude) else list()


## Helpers
diff_cmd = it.ifilter(os.path.exists, it.starmap(sh.join, it.imap(reversed,
	it.product(('colordiff', 'diff'), os.getenv('PATH').split(os.pathsep)) ))).next()
get_diff = lambda src,dst: exe.pipe((diff_cmd, '-uw', src, dst)).read()
def show_diff(src, dst=None):
	diff = get_diff(src, dst) if not dst is None else src
	if diff:
		log.warn(' <<<<<<<<< Source/Replacement diff:')
		sys.stderr.write(diff)
		log.warn(' >>>>>>>>> ')

def rel_src(src, dst):
	src, dst = map(os.path.abspath, (src, dst))
	dst = os.path.dirname(dst)
	src, dst = map(lambda x: x.split(os.sep), (src, dst))
	for i in range(min(len(dst), len(src))):
		if dst[i] != src[i]: break
		else: i +=1
	return os.path.join(*([os.pardir] * (len(dst)-i) + src[i:]))


### Init
T_SYM = 1 # symlink
T_RSYM = T_SYM | 2 # relative symlink
T_CR = 4 # catref
ops = {T_SYM: '->', T_RSYM: '+>', T_CR: '>'}

srcz = list() # filled during straight check to be used in reverse check
errz = 1
errz_critical = False # should be either false or equal to errz


### Backups dir
if optz.fix:
	bak_path = '/tmp/scim-lnck.{0}'.format(os.getpid())
	if os.path.exists(bak_path): sh.rr(bak_path)
	sh.mkdir(bak_path)


### Straight check (all linkz are correct)
if not scim_list: log.warn('No links-list file detected - no links are checked')

for line in scim_list:

	## Critical error bail-out
	if errz_critical is not False and errz > errz_critical:
		log.fatal('Critical error, further checks skipped')
		sys.exit()
	else: errz_critical = False

	## Get src, type, dst
	for ltype, aop in ops.iteritems():
		try: src,dst = line.split(' {0} '.format(aop))
		except ValueError: pass
		else: break
	else:
		log.error('Wrong link format: {0}'.format(line))
		log.warn('Uncorrectable error!')
		continue

	## Expand relative paths
	src = sh.join(scim_path, src)
	dst = sh.join(scim_path, os.path.expanduser(dst))
	if os.path.abspath(src) == os.path.abspath(scim_path):
		scim_path = dst # rebase on symlinked path
		errz_critical = errz # error here will lead to errors everywhere
	else:
		if os.path.isdir(src):
			log.debug('Linked whole path (bad practice): {0}'.format(src))
		srcz.append(src)

	if optz.limit and errz > optz.limit: continue # just fill srcz list

	## Check symlink / cat reference

	# Check link source
	if not os.path.exists(src):
		log.error("Source doesn't exists: {0}".format(src))
		log.warn('Uncorrectable error!')
	else:

		# Common check if dst exists at all
		if not os.path.lexists(dst):
			errz += 1
			log.error('No link destination: {0}'.format(dst))
			if optz.fix:
				if ltype & T_SYM:
					if ltype == T_RSYM: src = rel_src(src, dst)
					sh.ln(src, dst)
				elif ltype & T_CR: sh.cp_p(src, dst) # non-recursive: cat references to dirs aren't allowed
				log.info('Corrected: {0} -> {1}'.format(src, dst))
			continue # other checks need dst

		# Check if dst is the right type (symlink / reg file)
		if (ltype & T_SYM and not os.path.islink(dst)) or (ltype & T_CR and os.path.islink(dst)):
			errz += 1
			if ltype & T_SYM: log.error('Not a symlink: {0}'.format(dst))
			elif ltype & T_CR: log.error('Symlink in place of catref: {0}'.format(dst))
			if not optz.fix: show_diff(src, dst) # might be empty or erroneus if catref is replaced by bogus link
			else:
				sh.cp_p(src, bak_path)
				if not os.path.samefile(dst, src): sh.cp_cat(dst, src)
				sh.rm(dst)
				if ltype == T_RSYM: src = rel_src(src, dst)
				if ltype & T_SYM: sh.ln(src, dst)
				elif ltype & T_CR: sh.cp_p(src, dst)
				log.info('Corrected: {0} < {1} {2}'.format(src, aop, dst))
			continue # rest of the checks will be bogus anyway

		# Check target (symlink)
		if ltype & T_SYM:
			if ltype == T_RSYM:
				src = rel_src(src, dst)
				dst_tgt = os.readlink(dst)
			else: dst_tgt = os.path.realpath(dst)
			if dst_tgt != src:
				errz += 1
				log.error('Wrong symlink: {0} -> {1}, instead of {2}'.format(dst, dst_tgt, src))
				if optz.fix:
					sh.rm(dst)
					sh.ln(src, dst)
					log.info('Corrected: {0} -> {1}'.format(src, dst))

		# Check permissions and content (catref)
		elif ltype & T_CR:
			cps = False # there's common fix to all these problems - sh.cp_stat
			stat_src, stat_dst = os.stat(src), os.stat(dst)
			if stat_src.st_uid != stat_dst.st_uid:
				errz += 1
				if not optz.fix:
					log.error( 'Wrong UID: {0} - {1}, instead of {2}'\
						.format(dst, sh.uname(stat_dst.st_uid), sh.uname(stat_src.st_uid)) )
				else: cps = True
			if stat_src.st_gid != stat_dst.st_gid:
				errz += 1
				if not optz.fix:
					log.error( 'Wrong GID: {0} - {1}, instead of {2}'
						.format(dst, sh.gname(stat_dst.st_gid), sh.gname(stat_src.st_gid)) )
				else: cps = True
			stat_src, stat_dst = stat_src.st_mode & 0777, stat_dst.st_mode & 0777
			if stat_src != stat_dst:
				errz += 1
				if not optz.fix:
					log.error('Wrong mode: {0} - {1}, instead of {2}'.format(dst, oct(stat_src), oct(stat_dst)))
				else: cps = True
			if cps:
				try: sh.cp_stat(src, dst, attrz=True)
				except OSError, err:
					log.error('Unable to fix UID/GID/mode on {0}: {1}'.format(dst, err))
				else: log.info('Corrected UID/GID/mode: {0}'.format(dst))
			diff = get_diff(src, dst) # content diff
			if diff:
				errz += 1
				log.error('Different content: {0}'.format(src))
				if not optz.fix: show_diff(diff)
				else:
					sh.cp_cat(dst, src)
					log.info('Corrected: {0} > {1}'.format(dst, src))


### Reverse check that all files are listed in linkz, incorrectable
for node in sh.crawl(scim_path, exclude=scim_exclude):
	if optz.limit and errz > optz.limit: continue # just fill srcz list

	path = sh.join(scim_path, node)
	if path in srcz: continue
	if not os.path.isdir(path): # check if any of path parents is in srcz
		segz = path.split(os.sep)
		seg_path = '/'
		for seg in segz:
			seg_path = sh.join(seg_path, seg)
			if seg_path in srcz: break
		else:
			errz += 1
			log.warn('Not listed in linkz: {0}'.format(path))


### Cleanup
if optz.fix: sh.rr(bak_path)
